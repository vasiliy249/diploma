# Введение

## Актуальность работы

В связи с прогрессом в области информационных технологий наблюдается рост программного и 
аппаратного обеспечения, позволяющего решать многие задачи в различных сферах деятельности 
человека. Люди стали активно использовать платёжные системы, WEB-ресурсы для передачи данных, 
запоминающее устройства для записи и хранения важной информации и т.п. Всё это – заслуга 
компьютерных технологий. Однако в настоящее время активная интеграция современных 
информационных технологий практически во все области человеческой деятельности привела 
к тому, что с помощью программно-аппаратных средств и систем совершаются разного рода 
преступления (например, кража, мошенничество, лжепредпринимательство и др.). Кроме того, 
современные технологии также могут использоваться с целью фальсификации 
платежных документов, хищения наличных и безналичных денежных средств путем 
перечисления на фиктивные счета, вторичного получения уже произведенных выплат, 
продажи секретной информации и т.п.

Преступления, совершаемые с использованием компьютерных технологий, представляют 
серьезную угрозу для любой располагающей программно-аппаратным обеспечением организации. 
Такого рода преступления принято называть компьютерными преступлениями [1]. 
Наука, занимающаяся исследованием таких преступлений, называется компьютерной 
криминалистикой (иначе форензикой) [1]. Сам термин, форензика, произошёл от 
латинского «foren», что значит «речь перед форумом». В русский язык это слово 
пришло из английского. Полная форма этого термина на английском языке звучит 
следующим образом: «computer forensic science», что дословно означает 
«наука о компьютерной криминалистике». Согласно определению, форензика – 
это прикладная наука о раскрытии преступлений, связанных с компьютерной информацией, 
об исследовании цифровых доказательств, методах поиска, получения и закрепления таких 
доказательств, о применяемых для этого технических средствах [1].

Данная область криминалистики полноценно существует в развитых странах: издан ряд научных 
трудов (Windows Forensic Analysis Toolkit, Harlan Carvey; The Art of Memory Forensics, 
Michael Hale Ligh, Andrew Case, Jamie Levy, AAron Walters и т. д.) имеются учебные курсы, 
существуют официальные рекомендации, которым необходимо следовать при криминалистической 
экспертизе.

В других странах форензика лишь начинает развиваться. К сожалению, Россия относится 
как раз к таковым, не смотря на то, что в ней масса компьютерных специалистов высокого 
уровня. Например, одним из показателей является серийный выпуск программно-аппаратных 
комплексов, специализированных для сбора, обработки и анализа доказательств, 
для обеспечения целостности данных при изъятии и исследовании 
(например, PCI карта Tribble, проект WindowsSCOPE, LiMe и т. п.). 
В России такого рода обеспечение только начинает производиться, всё чаще закупается. 
Данное обстоятельство объясняется слаборазвитой научной платформой и 
отсутствием достаточного количества публикаций по данному направлению, отсутствием 
проработанной системы законов в компьютерно-криминалистической области 
(её заменяют небольшое количество статей). Также возможна причина в системе 
образования или наличии других, более оплачиваемых, IT-областей науки. 
Так или иначе, Россия пока отстаёт в этом направлении от других развитых стран.

Одной из задач компьютерной криминалистики является сбор и анализ информации, 
хранящейся на компьютере [1]. Сбор осуществляется с помощью класса методов снятия 
образов памяти - (на англ. - memory acquisition) [2]. Анализ и извлечение необходимых
 данных производится соответствующими методами карвинга данных (на англ. data carving) [3].  

Следует отметить, что данные на компьютере могут храниться и обрабатываться в 
следующих блоках памяти:

* регистры процессора,
* иерархическая кэш-память, 
* оперативная память компьютера,
* внешняя память компьютера.

В связи с тем, что первые два типа памяти являются специфичными и частично не 
адресуемыми для программиста, в этой работе они не рассматриваются. 

В данной работе будет уделено внимание классу методов анализа оперативной памяти. 

В настоящее время все большую популярность набирают технологии виртуализации. 
Растет пропускная способность интерфейсов компьютеров, а также емкость и отзывчивость 
систем хранения данных. В результате возникает такая ситуация, что имея такие мощности 
на одном физическом сервере, можно перенести в виртуальную среду все серверы, 
функционирующие в организации. [4] Таким образом технологии виртуализации в настоящее 
время становятся одним из ключевых компонентов современной ИТ-инфраструктуры крупных 
организаций. В связи с этим, возникает необходимость в мониторинге таких систем и 
анализе всевозможных инцидентов, произошедших на host-платформах, в рамках 
компьютерно-криминалистических экспертиз. Поэтому в данной работе будут описаны 
основные способы синтаксического анализа оперативной памяти виртуальных машин и 
методики мониторинга систем, использующих технологии виртуализации.

Основной задачей этой работы является изучение и применение данных методов для 
операционных систем семейства Windows. Данный выбор обусловлен тем, что эти 
операционные системы популярны среди большинства пользователей. 

Как упоминалось выше, существует множество инструментов для такого рода 
задач, но, к сожалению, у них есть свои недостатки, такие как большая стоимость 
известных решений, отсутствие открытого исходного кода и, как следствие, 
возможности в модификации каких-либо компонентов программы для определённых задач, 
платная техническая поддержка и т. п.

## Цель работы

Целью данной работы является создание архитектуры криминалистического 
программного-аппаратного комплекса, интегрированного с платформами виртуализации, 
в контексте проблемы интроспекционного анализа динамики оперативной памяти гостевых 
операционных систем.

## Задачи работы

Для достижения поставленной цели был сформулирован и решен ряд задач:

* исследование внутреннего устройства физического и виртуального пространства памяти в операционных системах Windows 7 x86_64;
* обзор известных методов и подходов при анализе образов оперативной памяти;
* разработка архитектуры программно-аппаратного комплекса.

# Глава 1.

## 1.1 Обзор существующих технологий

Существует множество аппаратных и программных средств для снятия и анализа 
необходимых данных. К ним относятся Belkasoft RAM Capturer, Volatility Framework, 
MANDIANT Memoryze, Guidance Software WinEn, FTK Imager, Moonsols DumpIt. 
Среди них есть прекрасные инструменты, решающие определённые задачи. 
Но эти средства имеют ряд недостатков. Большинство из них имеют высокую 
стоимость и закрытый исходный код, а основной недостаток заключается в их 
инвазивности, т.е. влиянии на исходные данные. При использовании данных 
инструментов возникает необходимость во внедрении собственного резидентного 
кода в оперативную память машины, что может в разной степени модифицировать 
исследуемую память. Это недопустимо с точки зрения корректности проведения 
компьютерно-криминалистической экспертизы. Поэтому возникает необходимость 
в создании архитектуры и дальнейшей разработки программного комплекса, 
который будет использовать метод неинвазивного анализа оперативной памяти. 
В данной работе будет уделено внимание созданию такого криминалистического 
программного инструмента, интегрированного с платформами виртуализации (прежде всего Qemu/KVM).

## 1.2 Технология. Теоретическая часть. 

## Общая информация о внутреннем устройстве операционных систем Windows.

Перед непосредственным проектированием программного комплекса следует 
предоставить общие сведения по устройству операционных систем Windows 7.

Операционная система — это комплекс взаимосвязанных системных программ, 
посредством которого пользователи и их программы взаимодействуют непосредственно 
с вычислительной техникой (железом?). Она предоставляет интерфейсы для пользователей 
и выполняющихся приложений. Программы пользователей, служебные программы, 
различные приложения взаимодействуют с аппаратурой компьютера только через 
обращение к операционной системе (точнее, к ядру операционной системы). 
Большинство операционных систем строятся из множества программных модулей. 
Существует группа «основных» управляющих модулей, вместе с некоторыми структурами 
системных данных она образует ядро операционной системы – центральную и основную 
часть системы. В зависимости от структурных особенностей ядра, операционные 
системы бывают различных типов: микроядерные и макроядерные (монолитные). 
В микроядерных операционных системах само ядро очень компактно, а остальные 
модули вызываются из ядра как сервисные. В отличие от микроядерной архитектуры, 
в макроядерных операционных системах главная «управляющая» часть включает в себя 
большое количество модулей и использует гораздо больше памяти. [5] Ядро Windows NT 
сочетает в себе элементы как микроядерной архитектуры, так и монолитной. 
Хотя Windows NT часто называют микроядерной операционной системой, это не совсем так. 
Данное ядро слишком велико, чтобы отнести его к типу микроядер, да и работа компонент 
ядра в одном адресном пространстве свойственна системам с монолитным ядром. 
С другой стороны, расположение и взаимодействие элементов ядра происходит точь-в-точь 
как в микроядерных системах. Такой тип ораганизации ядра называется «Гибридное ядро». 
Именно к этому, третьему, типу относится семейство операционных систем Windows NT. [6]

## Физическая и виртуальная память

В данной работе будут использоваться два термина – виртуальная память и физическая память. 
Под физической памятью подразумевается оперативная память, которая представляет 
упорядоченный набор однобайтовых ячеек, каждая из которых имеет свой уникальный адрес. 
Совокупность адресов в физической памяти, используемых для идентификации хранимых в 
памяти данных, называется физическим адресным пространством. Виртуальная память – это 
абстрактное хранилище, созданное самой операционной системой для удобства управления 
физической памятью. Виртуальная память позволяет программам считать, что им предоставлена 
неограниченная память и непрерывное адресное пространство. В операционной системе Windows 
она имеет сегментно-страничную организацию. Адресное пространство процесса представляется 
в виде набора сегментов переменного размера. Каждый сегмент делится на страницы – блоки 
фиксированного размера, при этом физическая память делится на блоки того же 
размера – фреймы. [7]

## Режим ядра и пользовательский режим

Чтобы предотвратить ситуации, когда пользовательские приложения получают 
доступ или вносят изменения в важные системные данные в Windows используются 
два процессорных режима доступа: пользовательский режим и режим ядра. 
Пользовательская программа функционирует в пользовательском режиме, а код 
операционной системы (например, системные службы и драйверы устройств) 
запускается в режиме ядра. Режим ядра — режим работы процессора, в котором 
имеется неограниченный доступ к системной памяти и внешним устройствам. 

Каждая страница в виртуальной памяти имеет пометку, показывающую, в каком режиме 
доступа должен быть процессор для чтения или записи этой страницы. Таким образом, 
происходит разделение виртуальной памяти операционной системы: пространство ядра 
(зарезервировано для работы ядра, его расширений и некоторый драйверов устройств) и 
пространство пользователя (в нём функционируют все приложения пользователя).

Как было сказано выше, большинство пользовательских приложений работает в 
режиме пользователя, однако, они могут осуществить переключение из пользовательского 
режима в режим ядра с помощью вызова системных служб. Такой переход осуществляется 
за счёт использования специальной инструкции процессора. Перед тем, как вернуть 
управление пользовательскому приложению, процессор переключается в прежний режим. [8]

## Восстановление адресного пространства процессов

При анализе оперативной памяти необходимо уметь восстанавливать адресное 
пространство процесса, то есть провести преобразование известных виртуальных 
адресов в соответствующие им физические, тем самым получив данные всех страниц 
виртуальной памяти из кадров (фреймов) оперативной памяти.

Трансляция виртуального адреса в физический производится посредством четырёхуровневой 
табличной структуры преобразований. Виртуальный адрес разделен на пять частей: 
селектор четвертого уровня отображения страницы, селектор указателя каталога страниц, 
селектор таблицы страниц, селектор записи таблицы страниц и байтовое смещение. 
При помощи этих указателей осуществляется преобразование адресов. [9]

## Поиск процессов

Анализ дампа ОП Windows 7 предполагает поиск активных процессов. Каждый процесс 
в ОП представлен как объект структуры _ERPOCESS, хранящейся в адресном пространстве ядра. 
У данной структуры есть множество свойств и подструктур, первая из них – 
подструктура _KPROCESS – блок управления процессом, он начинается с субструктуры 
_DISPATCHER_HEADER. Значения некоторых полей, которые она содержит, постоянны для 
всех процессов. Такими полями будут являться Type и Size. Таким образом, поиск 
процессов в оперативной памяти сводится к поиску соответствующего байтового паттерна 
в адресном пространстве ядра.

## Поиск информации о реестре

Реестр Windows - иерархически построенная база данных параметров и настроек в 
большинстве операционных систем Microsoft Windows. Реестр содержит информацию и 
настройки для аппаратного обеспечения, программного обеспечения, профилей пользователей, 
предустановки [10]. В памяти реестр представляет собой набор отдельных файлов, 
которые называются хайвами (на англ. Hive). Каждый хайв содержит дерево реестра и 
представлен в памяти структурой _CMHIVE. В данной структуре содержится множество 
метаданных, необходимых для анализа. Для поиска данной структуры можно воспользоваться 
выше упомянутым методом поиска соответствующего байтового паттерна в адресном 
пространстве ядра. В данном случае байтовым паттерном будет сигнатура, с которой 
начинается подструктура _HHIVE структуры _CMHIVE. [8]

## Анализ сетевых соединений

Информация о сетевых соединениях включает в себя идентификатор процесса, 
время создания, установленные соединения, локальный и удаленные адреса, 
локальный и удаленный порты. Извлечение информации о сетевых соединениях 
осуществляется аналогично описанным выше случаям – поиск сигнатуры структуры TCB и 
TcpEndpoint. [11]

## Гипервизор Qemu/KVM

Перед тем, как перейти к разработке архитектуры комплекса требуется изучить 
характеристики и особенности гипервизора Qemu/KVM. 

KVM (Kernel-based Virtual Machine) – это программное решение, обеспечивающее 
поддержку технологий виртуализации в среде Linux. Проект KVM зарекомендовал 
себя как надёжное программное обеспечение и входит в основную ветку Linux с 2007 года. 
Сам по себе KVM не выполняет эмуляции, он просто позволяет использовать виртуализацию на уровне ядра Linux. 

Для непосредственной эмуляции виртуальной машины необходим гипервизор. 
Для данной цели подходит QEMU (Quick Emulator) – бесплатный гипервизор с 
открытым исходным кодом позволяющий выполнять аппаратную виртуализацию. 
Первоначально, разработка данного продукта велась в рамках проекта KVM.  

В совокупности, данные два продукта позволяют использовать виртуализацию и 
выполнять эмуляцию виртуальных машин. В дальнейшем, в данной работе, под 
«гипервизором» будет пониматься совокупность двух данных программных решений.

Далее, рассмотрим подробнее работу гипервизора. 

Виртуальная машина, или target-платформа, создаётся путём запуска Qemu. Qemu 
позволяет запустить одновременно множество гостевых операционных систем (сколько?). 
Каждая из них будет определяться своим qemu-процессом на host-платформе.

![QemuProcesses](https://github.com/vasiliy249/diploma/blob/master/pictures/qemuKVM/qemuprocesses.png)

Когда гостевая операционная система выключается, процесс Qemu завершается. 
Перезагрузка гостевой ОС выполняется без перезапуска процесса Qemu.

После того, как запускается Qemu, выделяется оперативная память виртуальной машины. 
Она отображена в адресном пространстве процесса Qemu и выступает в роли «физической» для гостевой ОС.

![GuestMem](https://github.com/vasiliy249/diploma/blob/master/pictures/qemuKVM/GuestMem.png)

Виртуальная память гостевой ОС в свою очередь отображается на вышеупомянутую 
«физическую», как и в самом обычном случае стандартной операционной системы. 

Также стоит рассмотреть случай нескольких виртуальных машин. 
У каждой будет своя «физическая память» которая будет отображена на одну память – память host-платформы.

![MultGuestMemMap](https://github.com/vasiliy249/diploma/blob/master/pictures/qemuKVM/MultGuestMemMap.png)

Qemu поддерживает оба порядка записи байтов целевой (на англ. target) архитектуры – как от старшего 
к младшему (на англ. big-endian или «тупоконечный»), так и от младшего к старшему 
(на англ. little-endian или «остроконечный»). Поэтому доступ к памяти гостевой ОС 
через код Qemu должен производиться с внимательностью. Endian-преобразования выполняются 
вспомогательными функциями, а не путём доступа напрямую к оперативной памяти виртуальной машины.

Как было сказано выше, KVM – это функция виртуализации в ядре Linux, которая позволяет 
таким программам, как Qemu безопасно выполнять код гостевых систем непосредственно на 
процессоре host-платформы. Это возможно только тогда, когда архитектура целевой платформы 
поддерживается процессором host’a. 

Для того, чтобы выполнить код гостевой ОС с помощью KVM, процесc Qemu открывает 
директорию /dev/kvm и совершает системный вызов KVM_RUN IOCtl (input/output control – системный вызов потока ввода/вывода). 
Ядро модуля KVM использует аппаратные расширения виртуализации, поддерживаемые современными 
процессорами Intel и AMD для того чтобы напрямую исполнять код гостевой машины. Когда «гость» 
получает доступ к регистру аппаратного устройства, процессор виртуальной машины останавливает 
свою работу или выполняются другие специальные операции, KVM передаёт управление Qemu. 
В этот момент Qemu может сэмулировать желаемый результат операции или просто ждать следующего (???) 
прерывания сеанса гостевой ОС в случае остановки виртуального процессора.

Всё вышесказанное можно показать на кратком примере. Основной поток гостевого процессора выглядит следующим образом:
```
open("/dev/kvm")
ioctl(KVM_CREATE_VM)
ioctl(KVM_CREATE_VCPU)
for (;;) {
     ioctl(KVM_RUN)
     switch (exit_reason) {
     case KVM_EXIT_IO:  /* ... */
     case KVM_EXIT_HLT: /* ... */
     }
} 
```

Для host-платформы Qemu – это обычный процесс. Такие приложения, как Firefox или 
Apache также используют ресурсы host’a как и Qemu, хотя ресурсы можно распределить так, 
что Qemu будет выделен и поставлен в приоритет. В случае множественной виртуализации, адресные 
пространства процессов, соответствующие виртуальным машинам, могут располагаться рядом, в то 
время как сами виртуальные машины «не подозревают» друг о друге. 

Поскольку система эмуляции Qemu разработана так, что запущенная виртуальная машина будет 
располагаться целиком и непрерывно (без разделения на какие-либо функциональные блоки) в адресном 
пространстве процесса Qemu, такие детали, как запущенные процессы внутри гостевой ОС не видны 
непосредственно с host-платформы. Это сделано таким образом, чтобы Qemu мог предоставить «плиту» 
оперативной памяти виртуальной машины, способность выполнять код гостевой машины и эмулировать 
аппаратные устройства. Что в свою очередь позволяет запускать любую операционную систему на 
виртуальном аппаратном средстве (на англ. virtual hardware). Поэтому для host-платформы нет 
возможности «заглянуть внутрь» произвольной виртуальной машины.

Виртуальные машины имеют так называемый VCPU поток для каждого эмулируемого процессора. 
Выделенный поток ввода/вывода запускает цикл событий для обработки таких процессов, как 
сетевые соединения, завершение ввода/вывода информации с диска и т. п.  

![VCPUs vm](https://github.com/vasiliy249/diploma/blob/master/pictures/qemuKVM/VCPUs.png)

Следующая схема иллюстрирует, как виден Qemu процесс для host-платформы: 

![QemuProcHost](https://github.com/vasiliy249/diploma/blob/master/pictures/qemuKVM/QemuProcHost.png)

После того, как известны общие принципы работы Qemu/KVM, необходимо преступить к проектированию 
программно-аппаратного комплекса. 

## Архитектура программно-аппаратного комплекса

Для начала следует понять, что управлять виртуальными машинами, используя команды 
Qemu напрямую не совсем удобно и не представляется возможным ввиду дальнейшей автоматизации 
системы мониторинга. Поэтому было решено применить библиотеку управления виртуализации – libvirt.

Таким образом, наш комплекс снятия и синтаксического анализа дампов памяти использует библиотеку 
libvirt, которая, в свою очередь, используя непосредственно команды гипервизора управляет виртуальными машинами.

Алгоритм действий может быть описан следующим образом:

1. Снятие дампа физической памяти при помощи команды libvirt’a create snapshot на «живой» гостевой операционной системе без её приостановки.
2. Загрузка дампа непосредственно в заранее выделенное пространство оперативной памяти host-платформы.
3. Синтаксический анализ дампа с помощью разработанного программного обеспечения с целью выявления подозрительных активностей.
4. Принятие решения (например, приостановка системы)

Следует заметить, что все действия производятся неинвазивно, поскольку всё взаимодействие 
с гостевой ОС происходит через гипервизор. Таким образом, такая система будет корректной с 
точки зрения компьютерной криминалистического анализа.

![modelNow](https://github.com/vasiliy249/diploma/blob/master/pictures/model2.jpg)

Разумеется, хотелось бы получить доступ к физической памяти виртуальных машин напрямую 
с host-платформы, не используя никаких «прослоек», но, на первом этапе работы используется данный способ.

![modelfuture](https://github.com/vasiliy249/diploma/blob/master/pictures/model3.jpg)

В дальнейшем планируется проанализировать устройство отображения памяти гостевых ОС 
на память host-платформы, и, таким образом, получить доступ к физической памяти напрямую.


## Литература

1. Федотов Н.Н. Форензика – компьютерная криминалистика. – Москва: «Юридический мир», 2007. – 360 с.

2. Michael H. L., Andrew C., Jamie L., AAron W. The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory. – Indianapolis: John Wiley & Sons, Inc., 2014. – 886 p.

3. Digambar P, Bhadran V.K., Forensic Data Carving, Springer Berlin Heidelberg, 2011. – pp 137-148

4. Обзор методов виртуализации, архитектур и реализаций [Электронный ресурс]: URL: https://www.ibm.com/developerworks/ru/library/l-linuxvirt/index.html

5. Гордеев А. В. Операционные системы: Учебник для вузов. — 2-е изд. — СПб.: Питер, 2007. — 416 с.

6. MS Windows NT Kernel-mode User and GDI White Paper [Электронный ресурс]: URL:  https://technet.microsoft.com/library/cc750820.aspx

7. Виртуальное адресное пространство процесса [Электронный ресурс]: URL: http://www.intuit.ru/studies/courses/1089/217/lecture/5601

8. Russinovich M., Solomon D., Ionescu A. Windows Internals, Part 1, Sixth Edition. Redmond, Washington: Microsoft Press, 2012. - 726 p.

9. Russinovich M., Solomon D., Ionescu A. Windows Internals, Part 2, Sixth Edition. Redmond, Washington: Microsoft Press, 2012. - 645 p. 

10. Реестр Windows [Электронный ресурс]: URL: https://ru.wikipedia.org/wiki/Реестр_Windows

11. Lijuan. X, Lianhai. W, Shuhui. Z, Hengjian. L. A Method to Analyze Memory Images of 64-bit Windows 8, pp 304-312

