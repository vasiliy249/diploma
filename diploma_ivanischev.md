# Введение

## Актуальность работы

В связи с прогрессом в области информационных технологий наблюдается рост программного и 
аппаратного обеспечения, позволяющего решать многие задачи в различных сферах деятельности 
человека. Люди стали активно использовать платёжные системы, WEB-ресурсы для передачи данных, 
запоминающее устройства для записи и хранения важной информации и т.п. Всё это – заслуга 
компьютерных технологий. Однако в настоящее время активная интеграция современных 
информационных технологий практически во все области человеческой деятельности привела 
к тому, что с помощью программно-аппаратных средств и систем все чаще совершаются разного рода 
правонарушения и преступления: нарушения в области авторского и смежных прав, хищения денежных средств, мошенничество, лжепредпринимательство, продажи секретной информации и т.п.

Преступления, совершаемые с использованием компьютерных технологий, представляют 
серьезную угрозу как для коммерческих организаций, так и для государственных структур. 
Такого рода преступления принято называть компьютерными преступлениями [1]. 
Наука, занимающаяся исследованием таких преступлений, называется компьютерной 
криминалистикой (иначе форензикой) [1]. Сам термин, форензика, произошёл от 
латинского «foren», что значит «речь перед форумом». В русский язык это слово 
пришло из английского. Полная форма этого термина на английском языке звучит 
следующим образом: «computer forensic science», что дословно означает 
«наука о компьютерной криминалистике». Согласно определению, форензика – 
это прикладная наука о раскрытии преступлений, связанных с компьютерной информацией, 
об исследовании цифровых доказательств, методах поиска, получения и закрепления таких 
доказательств, о применяемых для этого технических средствах [1].

Данная область криминалистики полноценно существует в развитых странах: издан ряд научных 
трудов (Windows Forensic Analysis Toolkit, Harlan Carvey; The Art of Memory Forensics, 
Michael Hale Ligh, Andrew Case, Jamie Levy, AAron Walters и т. д.) имеются учебные курсы, 
существуют официальные рекомендации, которым необходимо следовать при криминалистической 
экспертизе.

В других странах форензика лишь начинает развиваться. К сожалению, Россия относится 
как раз к таковым, не смотря на то, что в ней масса компьютерных специалистов высокого 
уровня. Например, одним из показателей является серийный выпуск программно-аппаратных 
комплексов, специализированных для сбора, обработки и анализа доказательств, 
для обеспечения целостности данных при изъятии и исследовании 
(например, PCI карта Tribble, проект WindowsSCOPE, LiMe и т. п.). 
В России такого рода обеспечение только начинает производиться, всё чаще закупается. 
Данное обстоятельство объясняется слаборазвитой научной платформой и 
отсутствием достаточного количества публикаций по данному направлению, отсутствием 
проработанной системы законов в компьютерно-криминалистической области 
(её заменяют небольшое количество статей). Также возможна причина в системе 
образования или наличии других, более оплачиваемых, IT-областей науки. 
Так или иначе, Россия пока отстаёт в этом направлении от других развитых стран.

Одной из задач компьютерной криминалистики является сбор и анализ информации, 
хранящейся на компьютере [1]. Сбор осуществляется с помощью класса методов снятия 
образов памяти - (на англ. - memory acquisition) [2]. Анализ и извлечение необходимых
 данных производится соответствующими методами карвинга данных (на англ. data carving) [3].  

Следует отметить, что данные на компьютере могут храниться и обрабатываться в 
следующих блоках памяти:

* регистры процессора,
* иерархическая кэш-память, 
* оперативная память компьютера,
* внешняя память компьютера.

В связи с тем, что первые два типа памяти являются специфичными и частично не 
адресуемыми для программиста, в этой работе они не рассматриваются. 

В данной работе будет уделено внимание классу методов анализа оперативной памяти (ОП). 

В настоящее время все большую популярность набирают технологии виртуализации. 
Растет пропускная способность интерфейсов компьютеров, а также емкость и отзывчивость 
систем хранения данных. В результате возникает такая ситуация, что имея такие мощности 
на одном физическом сервере, можно перенести в виртуальную среду все серверы, 
функционирующие в организации. [4] Таким образом технологии виртуализации в настоящее 
время становятся одним из ключевых компонентов современной ИТ-инфраструктуры крупных 
организаций. В связи с этим, возникает необходимость в мониторинге таких систем и 
анализе всевозможных инцидентов, произошедших на host-платформах, в рамках 
компьютерно-криминалистических экспертиз. Поэтому в данной работе будут описаны 
основные способы синтаксического анализа оперативной памяти виртуальных машин и 
методики мониторинга систем, использующих технологии виртуализации.

Основной задачей этой работы является изучение и применение данных методов для 
операционных систем семейства Windows. Данный выбор обусловлен тем, что эти 
операционные системы популярны среди большинства пользователей. 

Как упоминалось выше, существует множество инструментов для такого рода 
задач, но, к сожалению, у них есть свои недостатки, такие как большая стоимость 
известных решений, отсутствие открытого исходного кода и, как следствие, 
возможности в модификации каких-либо компонентов программы для определённых задач, 
платная техническая поддержка и т. п.

## Цель работы

Целью данной работы является создание архитектуры криминалистического программного комплекса, интегрированного с платформами виртуализации, в контексте проблемы интроспекционного анализа динамики оперативной памяти гостевых операционных систем.

## Задачи работы

Для достижения поставленной цели был сформулирован и решен ряд задач:

* исследование внутреннего устройства физического и виртуального пространства памяти в операционных системах Windows 7 x86_64;
* обзор известных методов и подходов при анализе образов оперативной памяти;
* разработка архитектуры программно комплекса.

# Глава 1. Обзор существующих технологий

## 1.1. Общие сведения

Существует множество аппаратных и программных средств для снятия и анализа необходимых данных. К ним относятся Belkasoft RAM Capturer, Volatility Framework, MANDIANT Memoryze, Guidance Software WinEn, FTK Imager, Moonsols DumpIt. Среди них есть прекрасные инструменты, решающие определённые задачи. Но эти средства имеют ряд недостатков. Большинство из них имеют высокую стоимость и закрытый исходный код, а основной недостаток заключается в их инвазивности, т.е. влиянии на исходные данные. При использовании данных инструментов возникает необходимость во внедрении собственного резидентного кода в оперативную память машины, что может в разной степени модифицировать исследуемую память. Это недопустимо с точки зрения корректности проведения компьютерно-криминалистической экспертизы. Поэтому возникает необходимость в создании архитектуры и дальнейшей разработки программного комплекса, который будет использовать метод неинвазивного анализа оперативной памяти.

## 1.2. Volatility framework

Одной из задач данного комплекса будет являться анализ образцов оперативной памяти. С одной стороны, есть программные инструменты, которые решают данную проблему. Например, очень хорошее программное решение – Volatility Framework. Но Volatility подходит только в качестве обучающего инструмента. Есть ряд причин, по которым отсутствует возможность использования данного инструмента в этом проекте. Во-первых, это лицензия, под которой разрабатывается Volatility – это GNU GPL v2 – она имеет ряд недостатков перед BSD или MIT в нашем случае. Все недостатки не будут описываться в данной работе, один из них – это наложение определённых ограничений в случае использования данного приложения. Во-вторых, данное обеспечение разработано на языке программирования python, что не подходит для наших целей. Также, в ходе тестирования данного инструмента, было выявлено, что он не полностью приспособлен к работе с дампами (на англ. dump) памяти, получаемыми при помощи библиотеки libvirt.

## 1.3. Средства мониторинга виртуальных систем

Вторая, более глобальная задача, включающая в какой-то степени первую, - это наблюдение (или мониторинг) виртуальных машин. В данной области тоже имеется множество программных средств (Veeam One, Naumen и т. п.). Но, к сожалению, перед большинством из них стоит иная цель – увеличение производительности систем. Ещё один недостаток этих средств -  многие из них приспособлены к определённому гипервизору. Задача же этой работы состоит в том, чтобы создать архитектуру универсального комплекса наблюдения за состоянием виртуальных машин с целью выявления каких-либо нестандартных активностей.

Поэтому в данной работе будет уделено внимание созданию именно такого криминалистического программного инструмента, интегрированного с платформами виртуализации (прежде всего Qemu/KVM).

# Глава 2. Общая информация о внутреннем устройстве операционных систем Windows.

Перед непосредственным проектированием программного комплекса следует предоставить общие сведения по устройству операционных систем Windows 7.

## 2.1. Операционные системы и их типы

Операционная система — это комплекс взаимосвязанных системных программ, посредством которого пользователи и их программы взаимодействуют непосредственно с вычислительной техникой. Она предоставляет интерфейсы для пользователей и выполняющихся приложений. Программы пользователей, служебные программы, различные приложения взаимодействуют с аппаратурой компьютера только через обращение к операционной системе (точнее, к ядру операционной системы). Большинство операционных систем строятся из множества программных модулей. Существует группа «основных» управляющих модулей, вместе с некоторыми структурами системных данных она образует ядро операционной системы – центральную и основную часть системы. В зависимости от структурных особенностей ядра, операционные системы бывают различных типов: микроядерные и макроядерные (монолитные). В микроядерных операционных системах само ядро очень компактно, а остальные модули вызываются из ядра как сервисные. В отличие от микроядерной архитектуры, в макроядерных операционных системах главная «управляющая» часть включает в себя большое количество модулей и использует гораздо больше памяти. [5] Ядро Windows NT сочетает в себе элементы как микроядерной архитектуры, так и монолитной. Хотя Windows NT часто называют микроядерной операционной системой, это не совсем так. Данное ядро слишком велико, чтобы отнести его к типу микроядер, да и работа компонент ядра в одном адресном пространстве свойственна системам с монолитным ядром. С другой стороны, расположение и взаимодействие элементов ядра происходит точь-в-точь как в микроядерных системах. Такой тип ораганизации ядра называется «Гибридное ядро». Именно к этому, третьему, типу относится семейство операционных систем Windows NT. [6]

## 2.2. Физическая и виртуальная память

В данной работе будут использоваться два термина – виртуальная память и физическая память. Под физической памятью подразумевается оперативная память, которая представляет упорядоченный набор однобайтовых ячеек, каждая из которых имеет свой уникальный адрес. Совокупность адресов в физической памяти, используемых для идентификации хранимых в памяти данных, называется физическим адресным пространством. Виртуальная память – это абстрактное хранилище, созданное самой операционной системой для удобства управления физической памятью. Виртуальная память позволяет программам считать, что им предоставлена неограниченная память и непрерывное адресное пространство. В операционной системе Windows она имеет сегментно-страничную организацию. Адресное пространство процесса представляется в виде набора сегментов переменного размера. Каждый сегмент делится на страницы – блоки фиксированного размера, при этом физическая память делится на блоки того же размера – фреймы. [7]

## 2.3. Режим ядра и пользовательский режим

Чтобы предотвратить ситуации, когда пользовательские приложения получают доступ или вносят изменения в важные системные данные в Windows используются два процессорных режима доступа: пользовательский режим и режим ядра. Пользовательская программа функционирует в пользовательском режиме, а код операционной системы (например, системные службы и драйверы устройств) запускается в режиме ядра. Режим ядра — режим работы процессора, в котором имеется неограниченный доступ к системной памяти и внешним устройствам. 

Каждая страница в виртуальной памяти имеет пометку, показывающую, в каком режиме доступа должен быть процессор для чтения или записи этой страницы. Таким образом, происходит разделение виртуальной памяти операционной системы: пространство ядра (зарезервировано для работы ядра, его расширений и некоторый драйверов устройств) и пространство пользователя (в нём функционируют все приложения пользователя).

Как было сказано выше, большинство пользовательских приложений работает в режиме пользователя, однако, они могут осуществить переключение из пользовательского режима в режим ядра с помощью вызова системных служб. Такой переход осуществляется за счёт использования специальной инструкции процессора. Перед тем, как вернуть управление пользовательскому приложению, процессор переключается в прежний режим. [8]

## 2.4. Трансляция виртуального адреса в физический

При анализе оперативной памяти необходимо уметь восстанавливать адресное пространство процесса, то есть провести преобразование известных виртуальных адресов в соответствующие им физические, тем самым получив данные всех страниц виртуальной памяти из кадров (фреймов) оперативной памяти.

Трансляция виртуального адреса в физический производится посредством четырёхуровневой табличной структуры преобразований. Виртуальный адрес разделен на пять частей: селектор четвертого уровня отображения страницы, селектор указателя каталога страниц, селектор таблицы страниц, селектор записи таблицы страниц и байтовое смещение. При помощи этих указателей осуществляется преобразование адресов. В процессе преобразования могут попадаться недостоверные записи в таблицах страниц, поэтому необходимо учитывать специфику состояний найденных страниц. [9]

# Глава 3. Поиск сущностей операционной системы в дампах физической памяти Windows

Поиск сущностей операционной системы в дампах физической памяти осуществляется путём паттерного (на англ. pattern – образец) анализа. Его суть заключается в поиске определённого байтового паттерна в снимке памяти. Выбор паттерна зависит от сущности, которую необходимо обнаружить. На первом этапе работы таковыми будут являться список процессов, файл реестра и сетевые соединения.

## 3.1. Информация о процессах и их потоках

Первое, с чего следует начать при анализе дампа оперативной памяти операционной системы - это поиск списка активных процессов. Каждый процесс в ОП представлен как объект структуры _ERPOCESS, хранящейся в адресном пространстве ядра. У данной структуры есть множество свойств и подструктур, первая из них – подструктура _KPROCESS – блок управления процессом, он начинается с субструктуры _DISPATCHER_HEADER. Значения некоторых полей, которые она содержит, постоянны для всех процессов. Такими полями будут являться Type и Size. Таким образом, поиск процессов в оперативной памяти сводится к поиску соответствующего байтового паттерна в адресном пространстве ядра. 

Список результатов будет гораздо длиннее реального списка активных процессов, но после проверки определённых условий на адреса потоков процесса и поля DTB, которое совпадает с значением управляющего регистра CR3, некорректные «кандидаты» будут исключены. 

После нахождения объектов структуры _EPROCESS не составит труда найти информацию о процессах (имя, адрес и т. п.) и их потоках, т.к. описание структуры _EPROCESS известно.

## 3.2. Информация о реестре

Реестр Windows - иерархически построенная база данных параметров и настроек в большинстве операционных систем Microsoft Windows. Реестр содержит информацию и настройки для аппаратного обеспечения, программного обеспечения, профилей пользователей, предустановки [10]. В памяти реестр представляет собой набор отдельных файлов, которые называются хайвами (на англ. hive). Каждый хайв содержит дерево реестра и представлен в памяти структурой _CMHIVE. В данной структуре содержится множество метаданных, необходимых для анализа. Для поиска данной структуры можно воспользоваться выше упомянутым методом поиска соответствующего байтового паттерна в адресном пространстве ядра. В данном случае байтовым паттерном будет сигнатура, с которой начинается подструктура _HHIVE структуры _CMHIVE. Хайв устроен таким образом, что данные внутри него хранятся в ячейках (cells). По мере загруженности системы реестр Windows разрастается, и, т. к. всё это происходит в реальном времени, в физической памяти файл реестра хранится не равномерно, а с промежутками. Поэтому для того, чтобы получить полную информацию о реестре необходимо осуществлять «трансляцию» адресов ячеек. [8]

## 3.3. Информация о сетевых соединениях

Информация о сетевых соединениях включает в себя идентификатор процесса, время создания, установленные соединения, локальный и удаленные адреса, локальный и удаленный порты. Извлечение такой информации осуществляется аналогично описанным выше случаям – с помощью анализа соответствующих структур. В этом случае объектами исследования будут структуры TCB и TcpEndpoint. В роли байтового паттерна используется сигнатура этих структур. Произведя поиск данных сущностей, мы получим необходимую информацию. [11]

# Глава 4. Платформа виртуализации Qemu/KVM

Перед тем, как перейти к разработке архитектуры комплекса требуется изучить характеристики и особенности гипервизора Qemu/KVM. 

## 4.1. Общие сведения о KVM и Qemu

KVM (Kernel-based Virtual Machine) – это программное решение, обеспечивающее поддержку технологий виртуализации в среде Linux. Проект KVM зарекомендовал себя как надёжное программное обеспечение и входит в основную ветку Linux с 2007 года. Сам по себе KVM не выполняет эмуляции, он просто позволяет использовать аппаратную виртуализацию на уровне ядра Linux. 

Для непосредственной эмуляции виртуальной машины необходим гипервизор. Для данной цели подходит Qemu (Quick Emulator) – бесплатный гипервизор с открытым исходным кодом позволяющий выполнять аппаратную виртуализацию. Первоначально, разработка данного продукта велась в рамках проекта KVM.

В совокупности, данные два продукта позволяют использовать виртуализацию и выполнять эмуляцию виртуальных машин. В дальнейшем, в данной работе, под «гипервизором» будет пониматься совокупность двух данных программных решений.

## 4.2. Особенности работы гипервизора Qemu

Далее, рассмотрим подробнее работу гипервизора. 

Виртуальная машина, или target-платформа, создаётся путём запуска процесса Qemu. Теоретически, Qemu позволяет запустить одновременно бесконечное количество гостевых операционных систем. Данное число будет ограничиваться лишь ресурсами хостa (на англ. host). Каждая из гостевых операционных систем будет определяться своим Qemu-процессом на host-платформе (см. Рис. 4.1.).

![QemuProcesses](https://github.com/vasiliy249/diploma/blob/master/pictures/qemuKVM/qemuprocesses.png)

Когда гостевая операционная система выключается, процесс Qemu завершается. Перезагрузка гостевой ОС выполняется без перезапуска процесса Qemu.

После того, как запускается Qemu, выделяется оперативная память виртуальной машины. Она отображена в адресном пространстве процесса Qemu и выступает в роли «физической» для гостевой ОС (см. Рис. 4.2.).

![GuestMem](https://github.com/vasiliy249/diploma/blob/master/pictures/qemuKVM/GuestMem.png)

Виртуальная память гостевой ОС в свою очередь отображается на вышеупомянутую «физическую», как и в самом обычном случае стандартной операционной системы. 

Также стоит рассмотреть случай нескольких виртуальных машин. У каждой будет своя «физическая память» которая будет отображена на одну память – память host-платформы (см. Рис. 4.3.). 

![MultGuestMemMap](https://github.com/vasiliy249/diploma/blob/master/pictures/qemuKVM/MultGuestMemMap.png)

Qemu поддерживает оба порядка записи байтов целевой (на англ. target) архитектуры – как от старшего к младшему (на англ. big-endian или «тупоконечный»), так и от младшего к старшему (на англ. little-endian или «остроконечный»). Поэтому доступ к памяти гостевой ОС через код Qemu должен производиться с внимательностью. Endian-преобразования выполняются вспомогательными функциями, а не путём доступа напрямую к оперативной памяти виртуальной машины.

Как было сказано выше, KVM – это функция виртуализации в ядре Linux, которая позволяет таким программам, как Qemu безопасно выполнять код гостевых систем непосредственно на процессоре host-платформы. Это возможно только тогда, когда архитектура целевой платформы поддерживается процессором host’a. 

Для того, чтобы выполнить код гостевой ОС с помощью KVM, процесс Qemu открывает директорию /dev/kvm и совершает системный вызов KVM_RUN IOCtl (input/output control – системный вызов потока ввода/вывода). Ядро модуля KVM использует аппаратные расширения виртуализации, поддерживаемые современными процессорами Intel и AMD для того чтобы напрямую исполнять код гостевой машины. Когда «гость» получает доступ к регистру аппаратного устройства, процессор виртуальной машины останавливает свою работу или выполняются другие специальные операции, KVM передаёт управление Qemu. В этот момент Qemu может сэмулировать желаемый результат операции или просто ждать следующего (???) прерывания сеанса гостевой ОС в случае остановки виртуального процессора.

Всё вышесказанное можно показать на кратком примере. Основной поток гостевого процессора выглядит следующим образом:
```
open("/dev/kvm")
ioctl(KVM_CREATE_VM)
ioctl(KVM_CREATE_VCPU)
for (;;) {
     ioctl(KVM_RUN)
     switch (exit_reason) {
     case KVM_EXIT_IO:  /* ... */
     case KVM_EXIT_HLT: /* ... */
     }
} 
```

Для host-платформы Qemu – это обычный процесс. Такие приложения, как Firefox или Apache также используют ресурсы host’a как и Qemu, хотя ресурсы можно распределить так, что Qemu будет выделен и поставлен в приоритет. В случае множественной виртуализации, адресные пространства процессов, соответствующие виртуальным машинам, могут располагаться рядом, в то время как сами виртуальные машины не будут «подозревать» друг о друге. 

Поскольку система эмуляции Qemu разработана так, что запущенная виртуальная машина будет располагаться целиком и непрерывно (без разделения на какие-либо функциональные блоки) в адресном пространстве процесса Qemu, такие детали, как запущенные процессы внутри гостевой ОС не видны непосредственно с host-платформы. Это сделано для того, чтобы Qemu мог предоставить «плиту» оперативной памяти виртуальной машине, обеспечить способность выполнять код гостевой машины и эмулировать аппаратные устройства. Это, в свою очередь, позволяет запускать любую операционную систему на виртуальном аппаратном средстве (на англ. virtual hardware). Поэтому для host-платформы нет возможности «заглянуть внутрь» произвольной виртуальной машины.

Виртуальные машины имеют так называемый VCPU поток для каждого эмулируемого процессора. Выделенный поток ввода/вывода запускает цикл событий для обработки таких процессов, как сетевые соединения, завершение ввода/вывода информации с диска и т. п. (см. Рис. 4.4.).

![VCPUs vm](https://github.com/vasiliy249/diploma/blob/master/pictures/qemuKVM/VCPUs.png)

Следующая схема иллюстрирует, как виден Qemu процесс для host-платформы: 

![QemuProcHost](https://github.com/vasiliy249/diploma/blob/master/pictures/qemuKVM/QemuProcHost.png)

После того, как известны общие принципы работы Qemu/KVM, необходимо преступить к проектированию программно комплекса. 

# Глава 5. Архитектура программного комплекса

## 5.1. Библиотека управления виртуализацией libvirt

Для начала следует упомянуть, что управлять виртуальными машинами, используя команды Qemu напрямую не представляется возможным ввиду дальнейшей автоматизации и унификации системы мониторинга. Поэтому было решено применить библиотеку управления виртуализацией – libvirt, т. к. на данный момент она поддерживает большинство известных гипервизоров. Благодаря этому, программный комплекс становится универсальным и независящим от гипервизора.

Таким образом, наш программный инструмент, решая первую задачу – снятие дампа физической памяти, будет использовать библиотеку libvirt. Она, в свою очередь, используя непосредственно команды гипервизора, будет управлять виртуальными машинами.

## 5.2. Теоретический алгоритм работы

Алгоритм действий разрабатываемого программного комплекса может быть описан следующим образом:

1.Снятие дампа памяти.

Снятие дампа физической памяти виртуальной машины производится при помощи команды libvirt’a - create snapshot. Стоит подчеркнуть, что данное действие производится «наживую», т. е. без приостановки гостевой операционной системы.

2.Подготовка дампа памяти к анализу.

На этом этапе выделяется пространство в оперативной памяти host-платформы. Далее происходит загрузка дампа в данную область оперативной памяти. Фактически, снятие дампа происходит непосредственно в оперативную память хоста. Это позволяет добиться высоких результатов производительности.

3.Паттерный анализ дампа памяти.

На данном этапе происходит поиск сущностей операционной системы в дампе памяти с помощью методов, описанных выше в данной работе.

4.Анализ результатов поиска.

Подразумевается, что на входе мы имеем ряд правил, которым данный комплекс будет следовать. Поэтому на этапе анализа производится выявление нестандартных активностей и проверка условий, с целью получения дальнейших инструкций системе.

Следует заметить, что все действия производятся неинвазивно, поскольку всё взаимодействие с гостевой ОС происходит через гипервизор. Поэтому такая система будет корректной с точки зрения компьютерно-криминалистического анализа.

![modelNow](https://github.com/vasiliy249/diploma/blob/master/pictures/model.jpg)

Разумеется, хотелось бы получить доступ к физической памяти виртуальных машин напрямую с host-платформы, не используя никаких «прослоек», но, на первом этапе работы используется данный способ.

![modelfuture](https://github.com/vasiliy249/diploma/blob/master/pictures/modelFuture.jpg)

В дальнейшем планируется проанализировать устройство отображения памяти гостевых ОС на память host-платформы, и, таким образом, получить доступ к физической памяти target-платформы непосредственно.

# Глава 6. Эксперимент ???

# Заключение ???	

# Список литературы

1. Федотов Н.Н. Форензика – компьютерная криминалистика. Москва: «Юридический мир», 2007. 360 с.

2. Michael H. L., Andrew C., Jamie L., AAron W. The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory. Indianapolis: John Wiley & Sons, Inc., 2014. 886 p.

3. Digambar P, Bhadran V.K., Forensic Data Carving, Springer Berlin Heidelberg, 2011. pp 137-148.

4. Обзор методов виртуализации, архитектур и реализаций. https://www.ibm.com/developerworks/ru/library/l-linuxvirt/index.html

5. Гордеев А. В. Операционные системы: Учебник для вузов. 2-е изд. СПб: Питер, 2007. 416 с.

6. MS Windows NT Kernel-mode User and GDI White Paper. https://technet.microsoft.com/library/cc750820.aspx

7. Виртуальное адресное пространство процесса. http://www.intuit.ru/studies/courses/1089/217/lecture/5601

8. Russinovich M., Solomon D., Ionescu A. Windows Internals, Part 1, Sixth Edition. Redmond, Washington: Microsoft Press, 2012. 726 p.

9. Russinovich M., Solomon D., Ionescu A. Windows Internals, Part 2, Sixth Edition. Redmond, Washington: Microsoft Press, 2012. 645 p. 

10. Сведения о реестре Windows для опытных пользователей. https://support.microsoft.com/ru-ru/kb/256986

11. Lijuan. X, Lianhai. W, Shuhui. Z, Hengjian. L. A Method to Analyze Memory Images of 64-bit Windows 8, pp 304-312.
